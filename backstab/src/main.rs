#![feature(decl_macro)]
#[macro_use]
extern crate rocket;

use rocket::{response::status::BadRequest, State};

use std::collections::HashMap;
use std::str::FromStr;
use std::sync::{Arc, Mutex, RwLock};
use ts_rs::TS;

struct SessionsMap(RwLock<HashMap<SessionUuid, Arc<Mutex<Session>>>>);

type SessionUuid = u128;

struct Session {
    creator_identity: ClientIdentity,
    players: Vec<ClientIdentity>,
    broadcast: async_broadcast::Sender<ClientGameStateView>,
}

impl Session {
    fn new_with_creator(creator_identity: ClientIdentity) -> (Self, async_broadcast::Receiver<ClientGameStateView>) {
        let (sender, receiver) = async_broadcast::broadcast(1);
        (
            Self {
                creator_identity,
                players: vec![creator_identity],
                broadcast: sender,
            },
            receiver
        )
    }

    fn add_player(&mut self, identity: ClientIdentity) {
        if self
            .players
            .iter()
            .filter(|i| i.0 == identity.0)
            .next()
            .is_none()
        {
            self.players.push(identity);
        }
    }

    fn get_game_state_view(&self) -> ClientGameStateView {
        ClientGameStateView {
            number_of_players: self.players.len() as u8,
        }
    }
}

#[derive(TS)]
#[ts(export)]
#[derive(serde::Serialize, Clone)]
struct ClientGameStateView {
    number_of_players: u8,
}

#[derive(Clone, Copy)]
struct ClientIdentity(u128);

#[rocket::async_trait]
impl<'v> rocket::form::FromFormField<'v> for ClientIdentity {
    fn from_value(field: rocket::form::ValueField<'v>) -> rocket::form::Result<'v, Self> {
        match u128::from_str(field.value) {
            Ok(identity) => Ok(ClientIdentity(identity)),
            Err(_) => Err(rocket::form::Error::validation(
                "could not parse client identity",
            ))?,
        }
    }

    fn default() -> Option<Self> {
        None
    }
}

// NOTE: all requests should include a `X-Identity` header with a persistent identity generated by
// the client.

/// Creates a new session and sends the random code to the client.
/// Once created, client subscribes to the session's websocket.
#[get("/create-room?<identity>")]
fn create_room(
    identity: ClientIdentity,
    sessions: &State<SessionsMap>,
    ws: ws::WebSocket,
) -> ws::Channel<'static> {
    let random_code: u128 = 123456789; // TODO actually generate this randomly
    let (session, receiver) = Session::new_with_creator(identity);
    let session = Arc::new(Mutex::new(session));
    sessions
        .0
        .write()
        .unwrap()
        .insert(random_code, Arc::clone(&session));

    manage_game_socket(ws, identity, session, receiver)
}

/// Joins an existing session using its random code.
/// Once joined, client subscribes to the session's websocket.
#[get("/join-room?<identity>&<room>")]
fn join_room(
    identity: ClientIdentity,
    room: String,
    sessions: &State<SessionsMap>,
    ws: ws::WebSocket,
) -> Result<ws::Channel<'static>, BadRequest<String>> {
    let random_code = match u128::from_str(&room) {
        Ok(code) => code,
        Err(_) => return Err(BadRequest("couldn't parse room ID".to_string())),
    };
    let sessions = sessions.0.read().unwrap();
    if let Some(session) = sessions.get(&random_code) {
        let receiver;
        {
            let mut session = session.lock().unwrap();
            session.add_player(identity);
            receiver = session.broadcast.new_receiver();
        }
        Ok(manage_game_socket(ws, identity, Arc::clone(session), receiver))
    } else {
        return Err(BadRequest("session does not exist".to_string()));
    }
}

fn manage_game_socket(
    ws: ws::WebSocket,
    identity: ClientIdentity,
    session: Arc<Mutex<Session>>,
    receiver: async_broadcast::Receiver<ClientGameStateView>,
) -> ws::Channel<'static> {
    use rocket::futures::{SinkExt, StreamExt};
    use ws::Message;

    ws.channel(move |stream| {
        Box::pin(async move {
            let _identity = identity;
            let session = session;
            let broadcast = session.lock().unwrap().broadcast.clone();

            {
                // Send new game state to all clients, including this one
                let initial_gamestate = session.lock().unwrap().get_game_state_view();
                broadcast.broadcast(initial_gamestate).await.unwrap();
            }

            let (mut sink, stream) = stream.split();

            enum UnifiedStreamResult {
                FromWs(Result<Message, ws::result::Error>),
                FromServer(ClientGameStateView),
            }

            let mut events_stream = futures::stream_select!(
                stream.map(|e| UnifiedStreamResult::FromWs(e)),
                receiver.map(|e| UnifiedStreamResult::FromServer(e))
            );

            while let Some(message) = events_stream.next().await {
                match message {
                    UnifiedStreamResult::FromWs(m) => {
                        let _ = sink.send(m?).await;
                    }
                    UnifiedStreamResult::FromServer(m) => {
                        let _ = sink.send(Message::Text(serde_json::to_string(&m).unwrap())).await;
                    }
                }
            }

            Ok(())
        })
    })
}

#[rocket::launch]
fn rocket() -> _ {
    let sessions = SessionsMap(RwLock::new(HashMap::new()));
    rocket::build()
        .manage(sessions)
        .mount("/", routes![create_room, join_room])
}
