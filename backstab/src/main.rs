#![feature(decl_macro)]
#[macro_use] extern crate rocket;

use rocket::{
    State,
    Request,
    http::Status,
    response::status::BadRequest,
    request::Outcome,
};

use std::collections::HashMap;
use std::str::FromStr;
use std::sync::{Mutex, RwLock};

struct SessionsMap(RwLock<HashMap<SessionUuid, Mutex<Session>>>);

type SessionUuid = u128;

struct Session {
    creator_identity: ClientIdentity,
    players: Vec<ClientIdentity>,
}

impl Session {
    fn new_with_creator(creator_identity: ClientIdentity) -> Self {
        Self {
            creator_identity,
            players: vec![creator_identity]
        }
    }

    fn add_player(&mut self, identity: ClientIdentity) {
        self.players.push(identity);
    }
}

#[derive(Clone, Copy)]
struct ClientIdentity(u128);

#[rocket::async_trait]
impl<'r> rocket::request::FromRequest<'r> for ClientIdentity {
    type Error = String;

    async fn from_request(request: &'r Request<'_>) -> Outcome<Self, Self::Error> {
        if let Some(identity) = request.headers().get("X-Identity").next() {
            match u128::from_str(identity) {
                Ok(identity) => Outcome::Success(ClientIdentity(identity)),
                Err(_) => Outcome::Failure((Status::BadRequest, "could not parse client identity".to_string())),
            }
        } else {
            Outcome::Failure((Status::BadRequest, "missing client identity (X-Identity header)".to_string()))
        }
    }
}

// NOTE: all requests should include a `X-Identity` header with a persistent identity generated by
// the client.

/// Creates a new session and sends the random code to the client.
/// Once created, client should subscribe to the session's websocket.
#[get("/create-room")]
fn create_room(identity: ClientIdentity, sessions: &State<SessionsMap>) {
    let random_code: u128 = 123456789; // TODO actually generate this randomly
    let session = Session::new_with_creator(identity);
    sessions.0.write().unwrap().insert(random_code, Mutex::new(session));
}

/// Joins an existing session using its random code.
/// Once joined, client should subscribe to the session's websocket.
#[get("/join-room?<room>")]
fn join_room(identity: ClientIdentity, room: String, sessions: &State<SessionsMap>) -> Result<(), BadRequest<String>> {

    let random_code = match u128::from_str(&room) {
        Ok(code) => code,
        Err(_) => return Err(BadRequest(Some("couldn't parse room ID".to_string()))),
    };
    let sessions = sessions.0.read().unwrap();
    if let Some(session) = sessions.get(&random_code) {
        session.lock().unwrap().add_player(identity);
        Ok(())
    } else {
        Err(BadRequest(Some("session does not exist".to_string())))
    }
}

#[rocket::launch]
fn rocket() -> _ {
    let sessions = SessionsMap(RwLock::new(HashMap::new()));
    rocket::build().manage(sessions).mount("/", routes![create_room, join_room])
}
