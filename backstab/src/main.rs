#![feature(decl_macro)]
#[macro_use]
extern crate rocket;

use rocket::{http::Status, request::Outcome, response::status::BadRequest, Request, State};

use std::collections::HashMap;
use std::str::FromStr;
use std::sync::{Arc, Mutex, RwLock};

struct SessionsMap(RwLock<HashMap<SessionUuid, Arc<Mutex<Session>>>>);

type SessionUuid = u128;

struct Session {
    creator_identity: ClientIdentity,
    players: Vec<ClientIdentity>,
}

impl Session {
    fn new_with_creator(creator_identity: ClientIdentity) -> Self {
        Self {
            creator_identity,
            players: vec![creator_identity],
        }
    }

    fn add_player(&mut self, identity: ClientIdentity) {
        self.players.push(identity);
    }
}

#[derive(Clone, Copy)]
struct ClientIdentity(u128);

#[rocket::async_trait]
impl<'r> rocket::request::FromRequest<'r> for ClientIdentity {
    type Error = String;

    async fn from_request(request: &'r Request<'_>) -> Outcome<Self, Self::Error> {
        if let Some(identity) = request.headers().get("X-Identity").next() {
            match u128::from_str(identity) {
                Ok(identity) => Outcome::Success(ClientIdentity(identity)),
                Err(_) => Outcome::Failure((
                    Status::BadRequest,
                    "could not parse client identity".to_string(),
                )),
            }
        } else {
            Outcome::Failure((
                Status::BadRequest,
                "missing client identity (X-Identity header)".to_string(),
            ))
        }
    }
}

// NOTE: all requests should include a `X-Identity` header with a persistent identity generated by
// the client.

/// Creates a new session and sends the random code to the client.
/// Once created, client subscribes to the session's websocket.
#[get("/create-room")]
fn create_room(identity: ClientIdentity, sessions: &State<SessionsMap>, ws: ws::WebSocket) -> ws::Channel<'static> {
    let random_code: u128 = 123456789; // TODO actually generate this randomly
    let session = Arc::new(Mutex::new(Session::new_with_creator(identity)));
    sessions
        .0
        .write()
        .unwrap()
        .insert(random_code, Arc::clone(&session));

    manage_game_socket(ws, identity, session)
}

/// Joins an existing session using its random code.
/// Once joined, client subscribes to the session's websocket.
#[get("/join-room?<room>")]
fn join_room(
    identity: ClientIdentity,
    room: String,
    sessions: &State<SessionsMap>,
    ws: ws::WebSocket,
) -> Result<ws::Channel<'static>, BadRequest<String>> {
    let random_code = match u128::from_str(&room) {
        Ok(code) => code,
        Err(_) => return Err(BadRequest("couldn't parse room ID".to_string())),
    };
    let sessions = sessions.0.read().unwrap();
    if let Some(session) = sessions.get(&random_code) {
        session.lock().unwrap().add_player(identity);
        Ok(manage_game_socket(ws, identity, Arc::clone(session)))
    } else {
        return Err(BadRequest("session does not exist".to_string()));
    }
}

fn manage_game_socket(ws: ws::WebSocket, identity: ClientIdentity, session: Arc<Mutex<Session>>) -> ws::Channel<'static> {
    use rocket::futures::{SinkExt, StreamExt};

    ws.channel(move |mut stream| {
        Box::pin(async move {
            let _identity = identity;
            let _session = session;
            while let Some(message) = stream.next().await {
                let _ = stream.send(message?).await;
            }

            Ok(())
        })
    })
}

#[rocket::launch]
fn rocket() -> _ {
    let sessions = SessionsMap(RwLock::new(HashMap::new()));
    rocket::build()
        .manage(sessions)
        .mount("/", routes![create_room, join_room])
}
