-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

CREATE OR REPLACE FUNCTION public.submit_answer(
	p_user_id uuid,
	p_question_id bigint,
	p_answer_text text,
	p_allowed_response_time integer)
    RETURNS answers
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    game_id uuid;
    answer_record public.answers%rowtype;
    answer_exists boolean;
    question_created_at timestamp with time zone;
    response_time_exceeded boolean;
    all_answers_submitted boolean;
BEGIN
    -- Check if the user is in the game
    SELECT q.game, q.created_at INTO game_id, question_created_at
    FROM public.questions AS q
    JOIN public.player_games AS pg ON q.game = pg.game
    WHERE q.id = p_question_id AND pg.player = p_user_id;

    IF game_id IS NULL THEN
        RAISE EXCEPTION 'User is not in the game for the given question.'
        USING HINT = 'Ensure the user is in the game before submitting an answer.';
    END IF;

    -- Check if the response time is exceeded
    SELECT now() > (question_created_at + (p_allowed_response_time || ' seconds')::interval) INTO response_time_exceeded;

    IF response_time_exceeded THEN
        RAISE EXCEPTION 'The allowed response time has been exceeded for this question.'
        USING HINT = 'Ensure the answer is submitted within the allowed response time.';
    END IF;

    -- Check if the user has already submitted an answer for the question
    SELECT EXISTS (
        SELECT 1
        FROM public.answers
        WHERE question = p_question_id AND player = p_user_id
    ) INTO answer_exists;

    IF answer_exists THEN
        RAISE EXCEPTION 'User has already submitted an answer for this question.'
        USING HINT = 'Ensure the user has not submitted an answer before calling this function.';
    ELSE
        -- Submit the answer
        INSERT INTO public.answers (question, answer, player)
        VALUES (p_question_id, p_answer_text, p_user_id)
        RETURNING * INTO answer_record;

        -- Check if all players in the game have submitted answers
        SELECT NOT EXISTS (
            SELECT 1
            FROM public.player_games AS pg
            LEFT JOIN public.answers AS a ON a.player = pg.player AND a.question = p_question_id
            WHERE pg.game = game_id AND pg.is_voted_out = false AND a.id IS NULL
        ) INTO all_answers_submitted;

        IF all_answers_submitted THEN
            UPDATE public.games
            SET status = 'voting'
            WHERE id = game_id;
        END IF;

        RETURN answer_record;
    END IF;
END;
$BODY$;

ALTER FUNCTION public.submit_answer(uuid, bigint, text, integer)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.submit_answer(uuid, bigint, text, integer) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.submit_answer(uuid, bigint, text, integer) TO anon;

GRANT EXECUTE ON FUNCTION public.submit_answer(uuid, bigint, text, integer) TO authenticated;

GRANT EXECUTE ON FUNCTION public.submit_answer(uuid, bigint, text, integer) TO postgres;

GRANT EXECUTE ON FUNCTION public.submit_answer(uuid, bigint, text, integer) TO service_role;


CREATE TABLE IF NOT EXISTS public.votes
(
    question bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    player uuid NOT NULL,
    answer bigint NOT NULL,
    CONSTRAINT votes_pkey PRIMARY KEY (question, player, answer),
    CONSTRAINT votes_answer_fkey FOREIGN KEY (answer)
        REFERENCES public.answers (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT votes_player_fkey FOREIGN KEY (player)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT votes_question_fkey FOREIGN KEY (question)
        REFERENCES public.questions (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.votes
    OWNER to postgres;

ALTER TABLE IF EXISTS public.votes
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.votes TO anon;

GRANT ALL ON TABLE public.votes TO authenticated;

GRANT ALL ON TABLE public.votes TO postgres;

GRANT ALL ON TABLE public.votes TO service_role;

REVOKE ALL ON TABLE public.answers FROM authenticated;
REVOKE ALL ON TABLE public.answers FROM postgres;
REVOKE ALL ON TABLE public.answers FROM service_role;
GRANT ALL ON TABLE public.answers TO authenticated;

GRANT ALL ON TABLE public.answers TO service_role;

GRANT ALL ON TABLE public.answers TO postgres;

REVOKE ALL ON TABLE public.player_games FROM authenticated;
REVOKE ALL ON TABLE public.player_games FROM postgres;
REVOKE ALL ON TABLE public.player_games FROM service_role;
GRANT ALL ON TABLE public.player_games TO authenticated;

GRANT ALL ON TABLE public.player_games TO service_role;

GRANT ALL ON TABLE public.player_games TO postgres;
