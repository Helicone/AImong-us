-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

CREATE OR REPLACE FUNCTION public.voting_results_tick(
	p_game_id uuid,
	p_time_allowance_seconds integer,
	p_num_questions_per_game integer)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    v_game_state TEXT;
    v_most_recent_vote_time TIMESTAMP;
    v_num_questions INTEGER;
BEGIN
    -- Get the current game state and the most recent vote time
    SELECT g.status, MAX(v.created_at) INTO v_game_state, v_most_recent_vote_time
    FROM games g
    LEFT JOIN questions q ON q.game = g.id
    LEFT JOIN answers a ON a.question = q.id
    LEFT JOIN votes v ON v.answer = a.id
    WHERE g.id = p_game_id
    GROUP BY g.id;

    -- Get the total number of questions in the game
    SELECT COUNT(q.id) INTO v_num_questions
    FROM questions q
    WHERE q.game = p_game_id;

    -- Check conditions and update the game state accordingly
    IF v_game_state = 'voting_results' AND
       (now() - v_most_recent_vote_time) > (p_time_allowance_seconds * interval '1 second') THEN
        IF v_num_questions < p_num_questions_per_game THEN
            UPDATE games SET status = 'needs_question' WHERE id = p_game_id;
        ELSE
            UPDATE games SET status = 'game_over' WHERE id = p_game_id;
        END IF;
    END IF;
END;
$BODY$;

ALTER FUNCTION public.voting_results_tick(uuid, integer, integer)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.voting_results_tick(uuid, integer, integer) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.voting_results_tick(uuid, integer, integer) TO anon;

GRANT EXECUTE ON FUNCTION public.voting_results_tick(uuid, integer, integer) TO authenticated;

GRANT EXECUTE ON FUNCTION public.voting_results_tick(uuid, integer, integer) TO postgres;

GRANT EXECUTE ON FUNCTION public.voting_results_tick(uuid, integer, integer) TO service_role;

CREATE OR REPLACE FUNCTION public.start_game_tick(
	p_game_id uuid,
	p_time_allowance_seconds integer)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    v_game_state TEXT;
    v_last_player_join_time TIMESTAMP;
BEGIN
    -- Get the current game state
    SELECT status INTO v_game_state
    FROM games
    WHERE id = p_game_id;

    -- Get the time when the last player joined the game
    SELECT MAX(created_at) INTO v_last_player_join_time
    FROM player_games
    WHERE game = p_game_id;

    -- Check conditions and update the game state accordingly
    IF v_game_state = 'starting_game' AND
       (now() - v_last_player_join_time) > (p_time_allowance_seconds * interval '1 second') THEN
        UPDATE games SET status = 'needs_question' WHERE id = p_game_id;
    END IF;
END;
$BODY$;

ALTER FUNCTION public.start_game_tick(uuid, integer)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.start_game_tick(uuid, integer) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.start_game_tick(uuid, integer) TO anon;

GRANT EXECUTE ON FUNCTION public.start_game_tick(uuid, integer) TO authenticated;

GRANT EXECUTE ON FUNCTION public.start_game_tick(uuid, integer) TO postgres;

GRANT EXECUTE ON FUNCTION public.start_game_tick(uuid, integer) TO service_role;

CREATE OR REPLACE FUNCTION public.cast_vote(IN p_player_id uuid,IN p_answer_id bigint)
    RETURNS void
    LANGUAGE 'plpgsql'
    VOLATILE
    PARALLEL UNSAFE
    COST 100
    
AS $BODY$
DECLARE
    game_id uuid;
    question_id bigint;
    answer_exists boolean;
    all_votes_submitted boolean;
BEGIN
    -- Check if the game associated with the answer is in the 'voting' state
    SELECT q.game, q.id INTO game_id, question_id
    FROM public.answers AS a
    JOIN public.questions AS q ON a.question = q.id
    JOIN public.games AS g ON q.game = g.id
    WHERE a.id = p_answer_id AND g.status = 'voting';

    IF game_id IS NULL THEN
        RAISE EXCEPTION 'The game associated with the question is not in the "voting" state.'
        USING HINT = 'Ensure the game is in the "voting" state before casting a vote.';
    END IF;

    -- Check if the player has already voted for this question
    SELECT EXISTS (
        SELECT 1
        FROM public.votes AS v
        JOIN public.answers AS a ON v.answer = a.id
        WHERE a.question = question_id AND v.player = p_player_id
    ) INTO answer_exists;

    IF answer_exists THEN
        RAISE EXCEPTION 'Player has already voted for this question.'
        USING HINT = 'Ensure the player has not voted before calling this function.';
    ELSE
        -- Insert the vote into the votes table
        INSERT INTO public.votes (player, answer)
        VALUES (p_player_id, p_answer_id);

        -- Check if all players in the game have voted
        SELECT NOT EXISTS (
            SELECT 1
            FROM public.player_games AS pg
            LEFT JOIN public.votes AS v ON v.player = pg.player AND v.answer IN (SELECT a.id FROM public.answers AS a WHERE a.question = question_id)
            WHERE pg.game = game_id AND pg.is_voted_out = false AND v.player IS NULL
        ) INTO all_votes_submitted;

        IF all_votes_submitted THEN
            UPDATE public.games
            SET status = 'voting_results'
            WHERE id = game_id;
        END IF;
    END IF;
END;
$BODY$;

ALTER TABLE IF EXISTS public.player_games
    ADD COLUMN created_at timestamp without time zone NOT NULL DEFAULT now();

CREATE OR REPLACE VIEW public.answers_with_player_games
    AS
     SELECT a.id,
    a.created_at,
    a.question,
    a.answer,
    a.player,
    a.is_bot_answer,
    pg.random_player_number,
    count(v.created_at) AS vote_count
   FROM answers a
     JOIN player_games pg ON a.player = pg.player AND (a.question IN ( SELECT q.id
           FROM questions q
          WHERE q.game = pg.game))
     LEFT JOIN votes v ON a.id = v.answer
  GROUP BY a.id, a.created_at, a.question, a.answer, a.player, a.is_bot_answer, pg.random_player_number;
